resource来源
https://baike.baidu.com/item/最小权限原则/10956259

在计算机科学以及其它领域中，最小权限原则是要求计算环境中的特定抽象层的每个模块如进程、用户或者计算机程序只能访问当下所必需的信息或者资源。
赋予每一个合法动作最小的权限，就是为了保护数据以及功能避免受到错误或者恶意行为的破坏。最小权限原则也称为最少权限原则。


1.程序需要该权限吗？
如果程序不需要任何特殊权限来运行，它不应该是个特权程序。
2.程序需要所有权限吗？
我们只给予程序完成任务所需的最小权限集合。
许多操作系统不向我们提供多种选择；我们可以选择包含所有 Root 权限的集合，或者不包含任何权限的集合。多数 Unix 系统就是这样，你要么是 Root 要么不是，没有中间值。
多数现代 Unix 系统（和 Windows）引入了更多选择。这些系统将 Root 权限划分为多种字权限。使用这种自粒度，我们就可以更好应用最小权限原则 [2]  。
3.程序需要权限吗？
程序通常偶尔不需要特定权限，它们在这个时候就变得不必要了。我们应该暂时禁用它们来满足最小权限原则。这么做的好处就是，放置程序犯下意外的错误，使之不能对需要禁用权限的事情造成损失。下面的图像展示了这个要点。
稍后，禁用的权限可能就必要了，我们之后可以开启它。
要记住，开启或禁用权限可以在特定场景下降低损失，当攻击者不能像漏洞程序注入代码的时候。如果攻击者可以向漏洞程序注入代码，注入的代码自己就能够开启权限。
4.程序在未来需要权限吗？
如果权限不再需要了，它就是不必要的，应该永久溢出，所以最小权限集合应基于未来的需求来调整。


Unix 为我们提供了什么机制，来实现最小权限原则？ 
实用的系统调用：setuid()，seteuid()，setgid()，和setegid()。
seteuid(uid)：它为调用进程设置有效 UID。
如果调用进程的有效 UID 是超级用户，uid参数可以是任何东西。这通常由超级用户用来暂时让渡/获取权限。但是，进程的超级用户权限并没有丢失，进程可以拿回来。
如果调用进程的有效 UID 不是超级用户，UID 参数只能是有效 UID，真实 UID，以及保存的 UID。这通常由特权程序使用来恢复他的权限（原始的特权有效 UID 保存在保存的 UID 中）。
setuid(uid)：它设置了当前进程的有效 UID。如果调用者的有效 UID 是 Root，也会设置真实和保存的 UID。
如果调用进程的有效 UID 是超级用户，真实、有效和保存的 UID 全部会设为uid参数。之后，程序就不能够拿回 Root 权限（假设 UID 不是 Root）。这用于永久让渡高权限的访问权。
想要暂时放弃 Root 权限的 Set-Root-UID 程序，假设身份是非 Root 用户，之后不能使用setuid来拿回权限。你可以使用seteuid调用来完成它。
如果调用进程的有效 UID 不是超级用户，但是 UID 是调用进程的真实 UID 或者保存的 UID，那么有效 UID 会设置为uid。这类似于seteuid。
示例（在 Fedora 中）：进程使用有效 UID = 0 来运行，真实 UID= 500，在调用它们之后，有效和真实 UID 是什么？
setuid(500); setuid(0);：答案：500/500（第一个调用生成 500/500，第二个调用失败）。
seteuid(500); setuid(0);：答案：0/500（第一个调用生成 500/500，第二个调用生成 0/500）。
seteuid(600); setuid(500);：答案：500/500（第一个调用生成 600/500，第二个调用生成 500/500）。
seteuid(600); setuid(500); setuid(0);：答案：0/500（第一个调用生成 600/500，第二个调用生成 500/500，第三个调用生成 0/500）。